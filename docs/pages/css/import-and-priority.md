# CSS 引入方式与优先级

## 前言

在实际项目开发中，CSS 的引入方式直接影响样式的加载顺序和最终表现。不同的引入方式会产生不同的优先级，理解这些优先级规则能帮助我们解决样式覆盖问题。

## CSS 引入方式

### 1. 外部样式表（推荐）✨

通过 `<link>` 标签在 HTML 中引入外部 CSS 文件。

**HTML：**
```html
<!DOCTYPE html>
<html>
<head>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <p>Hello World</p>
</body>
</html>
```

**CSS（styles.css）：**
```css
p {
    color: blue;
    font-size: 16px;
}
```

**优点：**
- 样式与 HTML 分离，代码结构清晰
- CSS 文件可被浏览器缓存，多页面共用时性能最优
- 便于维护和扩展
- 支持媒体查询（Media Query）

**应用场景：** 大型项目、多页面应用、长期维护项目

### 2. 内部样式表

在 HTML 文件的 `<style>` 标签中定义样式。

```html
<!DOCTYPE html>
<html>
<head>
    <style>
        p {
            color: green;
            font-size: 18px;
        }
    </style>
</head>
<body>
    <p>Hello World</p>
</body>
</html>
```

**优点：**
- 样式定义在 HTML 文件内，单个文件包含所有样式
- 可以在 `<style>` 中使用某些动态内容

**缺点：**
- 不利于代码复用
- 无法被浏览器缓存
- 多个页面维护困难

**应用场景：** 小型项目、单页应用中的全局样式

### 3. 内联样式

直接在 HTML 元素上使用 `style` 属性。

```html
<p style="color: red; font-size: 20px;">Hello World</p>
```

**优点：**
- 样式作用范围明确，只作用于当前元素
- 不需要选择器

**缺点：**
- 不利于代码复用和维护
- 优先级最高，容易导致样式覆盖问题
- 违反关注点分离原则
- 不支持伪元素、媒体查询等

**应用场景：** 快速测试、紧急临时修改（不推荐在生产环境使用）

### 4. @import 规则

在 CSS 文件或 `<style>` 标签中使用 `@import` 导入其他 CSS 文件。

```html
<style>
    @import url('reset.css');
    @import url('styles.css');
</style>
```

或在 CSS 文件中：
```css
/* styles.css */
@import url('reset.css');

body {
    margin: 0;
}
```

**优点：**
- 可以在 CSS 中组织和管理多个文件

**缺点：**
- 会阻塞页面加载（在 `<style>` 中使用）
- 增加 HTTP 请求次数
- 性能表现不如 `<link>` 标签

**应用场景：** CSS 预处理器（Sass、Less）中使用文件组织

### 方式对比表

| 特性 | 外部样式表 | 内部样式表 | 内联样式 | @import |
|-----|---------|---------|--------|--------|
| 代码分离 | ✅ | ❌ | ❌ | ✅ |
| 可缓存性 | ✅ | ❌ | ❌ | ❌ |
| 代码复用 | ✅ | ❌ | ❌ | ✅ |
| 性能 | ✅ | ✅ | ✅ | ❌ |
| 易维护性 | ✅ | ✅ | ❌ | ✅ |
| 优先级 | 中 | 中 | 最高 | 中 |

## 引入方式的加载优先级

当使用多种 CSS 引入方式时，浏览器会根据以下优先级顺序应用样式：

### 加载优先级规则

```
内联样式 > 内部样式表 > 外部样式表 > @import
```

**详细说明：**

1. **内联样式** - 优先级最高，直接写在 HTML 元素的 `style` 属性上
2. **内部样式表** - 在 `<head>` 中的 `<style>` 标签定义的样式
3. **外部样式表** - 通过 `<link>` 标签引入的 CSS 文件
4. **@import** - 优先级最低（尤其是在 `<style>` 中使用时）

### 实战例子

**混合使用多种引入方式：**

```html
<!DOCTYPE html>
<html>
<head>
    <!-- 外部样式表 -->
    <link rel="stylesheet" href="styles.css">
    
    <!-- 内部样式表 -->
    <style>
        @import url('reset.css');
        
        p {
            color: blue;
            font-size: 18px;
        }
    </style>
</head>
<body>
    <!-- 内联样式 -->
    <p style="color: red;">Hello World</p>
</body>
</html>
```

**styles.css 内容：**
```css
p {
    color: green;
    font-size: 16px;
}
```

**reset.css 内容：**
```css
p {
    color: purple;
    font-size: 14px;
}
```

**最终效果：**
- 文本颜色为 **红色**（内联样式优先级最高）
- 字体大小为 **18px**（内部样式表 > 外部样式表 > @import）

**加载顺序与优先级分析：**

1. `reset.css` 加载 → p: color: purple, font-size: 14px
2. `styles.css` 加载 → p: color: green, font-size: 16px（覆盖 reset.css）
3. `<style>` 内部样式表 → p: color: blue, font-size: 18px（覆盖上述）
4. 内联样式 → style="color: red"（覆盖所有，仅 color 属性）

最终结果：color: red（内联），font-size: 18px（内部样式表）

## 开发建议与最佳实践

### ✅ 推荐做法

1. **优先使用外部样式表**
   - 便于维护，性能最优
   - 充分利用浏览器缓存机制

2. **避免使用 !important**
   - 避免与内联样式冲突
   - 如必须使用，应加注释说明原因

3. **合理组织 CSS 引入顺序**
   - 通常先使用 `<link>` 加载全局样式
   - 再使用 `<style>` 定义页面特殊样式
   - 最后使用内联样式处理特殊情况

### ❌ 避免做法

1. **过度依赖内联样式**
   - 难以维护，无法复用
   - 优先级过高，难以覆盖

2. **在 `<style>` 中使用 @import**
   - 会阻塞页面加载
   - 增加 HTTP 请求

3. **混乱的引入顺序**
   - 导致样式冲突难以排查
   - 增加维护成本

## 面试常见问题

**Q: CSS 有几种引入方式？各有什么优缺点？**

A: 四种引入方式：外部样式表、内部样式表、内联样式、@import。外部样式表最优（可缓存、易维护），内联样式优先级最高但不易维护，@import 会阻塞加载。

**Q: 不同引入方式的优先级是什么？**

A: 从高到低为：内联样式 > 内部样式表 > 外部样式表 > @import。同级别时，后定义的规则会覆盖先定义的规则。

**Q: @import 为什么性能不好？**

A: @import 会阻塞页面加载，特别是在 `<style>` 标签中使用时。相比之下，`<link>` 标签会并行加载，性能更优。

**Q: 如何解决不同引入方式导致的样式冲突？**

A: 理解引入方式的优先级规则，合理组织代码结构。通常用外部样式表定义全局样式，用内部样式表覆盖特殊情况，避免过度使用内联样式。

## 总结

- **引入方式选择**：优先使用外部样式表，确保代码分离和性能优化
- **优先级理解**：掌握不同引入方式的优先级规则，避免样式冲突
- **最佳实践**：组织清晰的 CSS 结构，减少维护成本和调试难度

在实际开发中，理解这些概念能帮助我们写出更专业、更易维护的样式代码。
